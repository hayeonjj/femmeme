<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS GAME</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Gothic+A1&family=Noto+Sans+KR:wght@100..900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color:white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: "Gothic A1", sans-serif;
            font-weight: 700;
            font-style: normal;
            color: #FF0000;
        }
        ::selection {
            background-color: rgb(255, 255, 0);
            color: #FF0000;
        }
        #game-container { display: flex; }
        #tetris-area {
            background-color: white;
            /* JavaScript에서 너비와 높이가 동적으로 설정됩니다. */
        }
        #next-jamo-container {
            width: 100px;
            height: 100px;
            border: 3px solid rgba(255, 0, 0) ;
            border-radius: 4px;
            background-color:rgba(255, 255, 255, 0.4);
            position: absolute;
            left: 20px;
            bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
        }
        #start-message {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            text-align: center;
            pointer-events: none;
        }
        #combine-button {
            display: none; /* 처음에는 숨겨둡니다. */
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
        }
        #result-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #333;
            display: none; /* 처음에는 숨겨둡니다. */
        }
        .tetris-cell {
            width: 50px; /* 임시 크기 */
            height: 50px; /* 임시 크기 */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            color: #222;
            box-sizing: border-box;
            /* border: 1px solid #ddd; */ /* 개발 중 확인용 */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="tetris-area"></canvas>
        <div id="next-jamo-container"></div>
        <div id="start-message">* 방향키를 눌러 시작하세요 *</div>
        <button id="combine-button">자모 조합</button>
        <div id="result-display"></div>
    </div>

    <script>
        const tetrisArea = document.getElementById('tetris-area');
        const nextJamoContainer = document.getElementById('next-jamo-container');
        const startMessage = document.getElementById('start-message');
        const combineButton = document.getElementById('combine-button');
        const resultDisplay = document.getElementById('result-display');
        const context = tetrisArea.getContext('2d');

        let gameStarted = false;
        let grid = []; // 테트리스 영역의 상태를 저장할 2차원 배열 (각 셀은 초/중/종성 문자열 또는 null)
        let currentJamo = null; // 현재 떨어지는 자모 (문자열: 초성, 중성, 또는 종성)
        let nextJamo = null; // 다음에 나올 자모 (문자열)
        let nextJamoTypeIndex = 0; // 다음에 나올 자모 타입 (0: 종성, 1: 중성, 2: 초성)
        let animationFrameId; // requestAnimationFrame ID
        let fastDropInterval = null; // 빠르게 떨어지는 간격의 ID를 저장

        const initialChosung = ['ㄱ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅍ', 'ㅎ'];
        const jungsung = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅗ', 'ㅛ', 'ㅜ', 'ㅠ', 'ㅡ', 'ㅣ', 'ㅘ', 'ㅖ'];
        const jongsungBase = ['','ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅍ', 'ㅎ']

        let cellWidth;
        let cellHeight;
        let gridHeight = 9; // 변경된 높이 (3칸씩 쌓인 곳이 3군데 이상)
        let gridWidth;

        function getRandomJamo(jamoType) {
            if (jamoType === 'chosung') {
                return initialChosung[Math.floor(Math.random() * initialChosung.length)];
            } else if (jamoType === 'jungsung') {
                return jungsung[Math.floor(Math.random() * jungsung.length)];
            } else if (jamoType === 'jongsung') {
                if (Math.random() < 0.7) {
                    return jongsungBase[Math.floor(Math.random() * jongsungBase.length)];
                } else {
                    return null;
                }
            }
            return null;
        }

        function getNextJamoType() {
            const types = ['jongsung', 'jungsung', 'chosung'];
            const type = types[nextJamoTypeIndex];
            nextJamoTypeIndex = (nextJamoTypeIndex + 1) % types.length;
            return type;
        }

        function generateNewJamo() {
            const type = getNextJamoType();
            return getRandomJamo(type);
        }

        function displayJamo(jamo, container) {
            container.textContent = jamo || '';
        }

        function createGrid() {
            cellWidth = 50; // 자모가 들어갈 셀의 너비
            cellHeight = 50; // 자모가 들어갈 셀의 높이
            gridWidth = Math.floor(window.innerWidth / cellWidth); // 전체 화면 너비에 맞춘 가로 칸 수

            const dpr = window.devicePixelRatio || 1;
            tetrisArea.width = gridWidth * cellWidth * dpr; // 실제 픽셀 크기 증가
            tetrisArea.height = gridHeight * cellHeight * dpr; // 실제 픽셀 크기 증가
            context.scale(dpr, dpr);

            // CSS를 사용하여 보여지는 크기는 이전과 동일하게 설정
            tetrisArea.style.width = `${gridWidth * cellWidth}px`;
            tetrisArea.style.height = `${gridHeight * cellHeight}px`;

            grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(null));
        }

        function drawGrid() {
            context.clearRect(0, 0, tetrisArea.width, tetrisArea.height);

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[0].length; x++) {
                    if (grid[y][x]) {
                        context.fillStyle = '#ff99fa'; //블록 색깔 변경 
                        context.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                        context.strokeStyle = '#999';
                        context.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                        context.fillStyle = '#7FFF00'; //폰트 색깔 변경 
                        context.font = `${cellHeight * 0.7}px Gothic A1`;
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(grid[y][x], x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2);
                    } else {
                        context.strokeStyle = '#FF0000'; //빈 셀 그리드 선 
                        context.lineWidth = 1; //빈 셀 그리드 선 굵기 설정 
                        context.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            if (currentJamo !== null) {
                context.fillStyle = '#7FFF00'; //현재 떨어지는 블록 색깔 변경 
                const x = currentJamo.x;
                const y = currentJamo.y;
                context.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                context.fillStyle = '#FF0000';
                context.font = `${cellHeight * 0.7}px Gothic A1`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(currentJamo.value, x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2);
            }
        }

        function moveJamo(direction) {
            if (!currentJamo) return;
            let newX = currentJamo.x + (direction === 'left' ? -1 : 1);
            if (newX >= 0 && newX < gridWidth && !isCollision(currentJamo.value, newX, currentJamo.y)) {
                currentJamo.x = newX;
                drawGrid();
            }
        }

        function dropJamo() {
            if (!currentJamo) return;
            let newY = currentJamo.y + 1;
            if (newY < gridHeight && !isCollision(currentJamo.value, currentJamo.x, newY)) {
                currentJamo.y = newY;
            } else {
                // 충돌 발생 또는 바닥에 닿음
                if (currentJamo.y < gridHeight) {
                    grid[currentJamo.y][currentJamo.x] = currentJamo.value;
                }
                currentJamo = null;
                if (!nextJamo) {
                    nextJamo = generateNewJamo();
                    displayJamo(nextJamo, nextJamoContainer);
                }
                spawnNewJamo();
                console.log("checkStackedRowsCount:", checkStackedRowsCount()); // 추가
                if (checkStackedRowsCount() >= 3) {
                    showCombineButton();
                    console.log("showCombineButton 호출됨"); // 추가
                }
                return; // 멈췄으므로 더 이상 아래로 이동하지 않음
            }
            drawGrid();
            setTimeout(dropJamo, 2000); // 속도를 3배 느리게
        }

        function dropJamoFast() {
            if (!currentJamo) return;
            let newY = currentJamo.y + 1;
            if (newY < gridHeight && !isCollision(currentJamo.value, currentJamo.x, newY)) {
                currentJamo.y = newY;
                drawGrid();
            } else {
                // 충돌 발생 또는 바닥에 닿음
                if (currentJamo.y < gridHeight) {
                    grid[currentJamo.y][currentJamo.x] = currentJamo.value;
                }
                currentJamo = null;
                if (!nextJamo) {
                    nextJamo = generateNewJamo();
                    displayJamo(nextJamo, nextJamoContainer);
                }
                spawnNewJamo();
                console.log("checkStackedRowsCount (fast):", checkStackedRowsCount()); // 추가
                if (checkStackedRowsCount() >= 3) {
                    showCombineButton();
                    console.log("showCombineButton 호출됨 (fast)"); // 추가
                }
                clearInterval(fastDropInterval); // 빠르게 떨어지는 간격 해제
                fastDropInterval = null;
                return;
            }
        }

        function isCollision(value, x, y) {
            if (y >= gridHeight || x < 0 || x >= gridWidth) {
                return true;
            }
            return grid[y][x] !== null;
        }

        function spawnNewJamo() {
            const newJamoValue = nextJamo;
            nextJamo = generateNewJamo();
            displayJamo(nextJamo, nextJamoContainer);

            if (newJamoValue !== null) {
                currentJamo = {
                    value: newJamoValue,
                    x: Math.floor(gridWidth / 2) - 1,
                    y: 0 // 시작 위치를 맨 위로 변경
                };
                dropJamo();
            } else {
                // 종성이 나오지 않았으면 다음 자모 생성 시도
                spawnNewJamo();
            }
        }

        function checkStackedRowsCount() {
            let stackedRowCount = 0;
            for (let y = 0; y <= gridHeight - 3; y++) { // 마지막 2줄이 아닌, 3줄 묶음을 확인
                if (grid[y].every(cell => cell !== null) &&
                    grid[y + 1].every(cell => cell !== null) &&
                    grid[y + 2].every(cell => cell !== null)) {
                    stackedRowCount++;
                }
            }
            return stackedRowCount;
        }

        function showCombineButton() {
            combineButton.style.display = 'block';
        }

        function combineJamo() {
            if (checkStackedRowsCount() < 3) {
                alert("3칸씩 채워진 부분이 3군데 이상 되어야 합니다.");
                return;
            }

            let combinedText = "";
            for (let y = 0; y <= gridHeight - 3; y++) {
                if (grid[y].every(cell => cell !== null) &&
                    grid[y + 1].every(cell => cell !== null) &&
                    grid[y + 2].every(cell => cell !== null)) {
                    const chosung = grid[y][0];
                    const jungsung = grid[y + 1][0];
                    const jongsung = grid[y + 2][0]; // 일단 첫 번째 칸의 자모를 가져옴

                    const chosungIndex = initialChosung.indexOf(chosung);
                    const jungsungIndex = jungsung.indexOf(jungsung);
                    const jongsungIndex = jongsungBase.indexOf(jongsung);

                    if (chosungIndex !== -1 && jungsungIndex !== -1) {
                        const unicodeValue = 44032 + (chosungIndex * 588) + (jungsungIndex * 28) + jongsungIndex;
                        combinedText += String.fromCharCode(unicodeValue);
                    } else {
                        alert("유효한 한글 조합이 아닙니다.");
                        return;
                    }
                    break; // 일단 첫 번째 완성된 3층만 처리하고 종료
                }
            }

            if (combinedText) {
                resultDisplay.textContent = combinedText;
                resultDisplay.style.display = 'block';
            } else {
                alert("유효한 한글 조합을 찾지 못했습니다.");
            }
        }

        document.addEventListener('keydown', (event) => {
            if (!gameStarted) {
                startMessage.style.display = 'none';
                gameStarted = true;
                createGrid();
                nextJamo = generateNewJamo();
                displayJamo(nextJamo, nextJamoContainer);
                spawnNewJamo();
                return;
            }

            if (event.key === 'ArrowLeft') {
                moveJamo('left');
            } else if (event.key === 'ArrowRight') {
                moveJamo('right');
            } else if (event.key === 'ArrowDown') {
                // 아래 방향키를 누르고 있는 동안 빠르게 떨어뜨림
                if (!fastDropInterval && currentJamo) {
                    fastDropInterval = setInterval(dropJamoFast, 100); // 0.03초마다 이동 (더 짧은 간격)
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.key === 'ArrowDown') {
                // 아래 방향키에서 손을 떼면 빠르게 떨어지는 간격 해제
                clearInterval(fastDropInterval);
                fastDropInterval = null;
            }
        });

        combineButton.addEventListener('click', combineJamo);

        // 초기화
        createGrid();
        drawGrid();
    </script>
</body>
</html>
