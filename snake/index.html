<!DOCTYPE html>
<html lang="en">
<head>
    <title>자모 지렁이</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Gothic+A1&family=Noto+Sans+KR:wght@100..900&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            background-color: white;
            color: #FF0000;
            font-family: "Gothic A1", sans-serif;
            font-weight: 700;
            font-style: normal;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        ::selection {
            background-color: rgb(255, 255, 0);
            color: #FF0000;
        }
        #threejs-container {
            position: relative;
            display: none; /* 초기 숨김 */
        }
        #start-selection {
            margin-bottom: 20px;
            font-weight: 700;
            text-align: center;
        }
        .chosung-option {
            display: inline-block;
            margin: 5px;
            padding: 10px;
            border-radius: 4px;
            font-size: 32px;
            font-weight: 900;
            background-color: #7FFF00;
            -webkit-transition: .3s ease-in-out;
            cursor: pointer;
            -webkit-transition: .3s ease-in-out;
            transition: .3s ease-in-out;
        }

        .chosung-option:hover {
            /*background:linear-gradient(45deg,#FFDC80,#F77737,#FD1D1D, #C13584, #833AB4);
            background-size: 800%;*/
            filter:blur(3px);
            -webkit-transition: .3s ease-in-out;
            transition: .3s ease-in-out;
        }

        #start-info {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            text-align: center;
            pointer-events: none;
        }
        .hidden {
            display: none !important;
        }

        #next-button {
            position: absolute;
            right: 20px;
            bottom: 20px;
            padding: 15px 30px;
            font-family: "Gothic A1", sans-serif;
            font-weight: 700;
            font-style: normal;
            font-size: 20px;
            background-color: #FF0000; /* '글자 조합' 버튼과 동일한 색상 */
            color: white;
            /*outline-style: solid;
            outline-color:#FF0000;
            outline-width: 2.5px;*/
            border: none;
            border-radius: 4px;
            -webkit-transition: .3s ease-in-out;
            cursor: pointer;
            -webkit-transition: .3s ease-in-out;
            transition: .3s ease-in-out;
        }

        #next-button:hover {
            filter:blur(3px);
            -webkit-transition: .3s ease-in-out;
            transition: .3s ease-in-out;
        }

        #combination-area {
            display: none;
            flex-direction: column; /* 세로로 배치 */
            align-items: center; /* 가운데 정렬 */
        }
        #combination-area h2 {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            text-align: center;
        }
        #captured-jamo {
            font-size: 2em;
            margin-bottom: 20px;
        }
        .draggable-jamo {
            display: inline-block;
            padding: 10px;
            margin: 5px;
            cursor: grab;
            font-size: 32px;
            border-radius: 4px;
            background-color: #ff99fa;
            position: relative; /* for absolute positioning during drag */
            -webkit-user-select:none;
            -moz-user-select:none;
            -ms-user-select:none;
            user-select:none
        }
        #capture-result {
            position: absolute; /* '글자 조합' 버튼과 동일한 위치 */
            right: 20px;
            bottom: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background-color: #FF0000; /* '글자 조합' 버튼과 동일한 색상 */
            color: white;
            /*outline-style: solid;
            outline-color:#FF0000;
            outline-width: 2.5px;*/
            border: none;
            border-radius: 4px;
            margin-top: 20px; /* 기존 margin 제거 */
            -webkit-transition: .3s ease-in-out;
            cursor: pointer;
            -webkit-transition: .3s ease-in-out;
            transition: .3s ease-in-out;
        }
        #capture-result:hover {
            filter:blur(3px);
            -webkit-transition: .3s ease-in-out;
            transition: .3s ease-in-out;
        }
    </style>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.1/dist/es-module-shims.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="start-selection">
        <h2>* 플레이어를 선택하세요 *</h2>
        <div id="chosung-list">
            <span class="chosung-option" data-chosung="ㅆ">ㅆ</span>
            <span class="chosung-option" data-chosung="ㄱ">ㄱ</span>
            <span class="chosung-option" data-chosung="ㅊ">ㅊ</span>
            <span class="chosung-option" data-chosung="ㅅ">ㅅ</span>
            <span class="chosung-option" data-chosung="ㅈ">ㅈ</span>
            <span class="chosung-option" data-chosung="ㅇ">ㅇ</span>
            <span class="chosung-option" data-chosung="ㅃ">ㅃ</span>
            <span class="chosung-option" data-chosung="ㅂ">ㅂ</span>
            <span class="chosung-option" data-chosung="ㄹ">ㄹ</span>
            <span class="chosung-option" data-chosung="ㅅ">ㅅ</span>
            <span class="chosung-option" data-chosung="ㅋ">ㅋ</span>
            <span class="chosung-option" data-chosung="ㅍ">ㅍ</span>
            <span class="chosung-option" data-chosung="ㄷ">ㄷ</span>
            <span class="chosung-option" data-chosung="ㅌ">ㅌ</span>
            <span class="chosung-option" data-chosung="ㅁ">ㅁ</span>
            <span class="chosung-option" data-chosung="ㄴ">ㄴ</span>
            <span class="chosung-option" data-chosung="ㄸ">ㄸ</span>
            <span class="chosung-option" data-chosung="ㅍ">ㅍ</span>
            <span class="chosung-option" data-chosung="ㅎ">ㅎ</span>
        </div>
    </div>
    <div id="threejs-container">
        <div id="start-info">
            <div>* 방향키를 눌러 시작하세요 *</div>
        </div>
        <button id="next-button" class="hidden">글자 조합</button>
    </div>
    <div id="combination-area">
        <h2></h2>
        <div id="captured-jamo"></div>
        <button id="capture-result">캡처</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // 장면, 카메라, 렌더러
        let scene, camera, renderer;
        // 플레이어
        let playerSegments = [];
        const segmentLength = 1.5;
        const moveSpeed = 0.03;
        const rotateSpeed = 0.1;
        let targetDirection = new THREE.Vector3(1, 0, 0); // 초기 이동 방향
        let currentDirection = new THREE.Vector3(1, 0, 0);
        let isMoving = false;
        const segmentPositions = [];
        // 자모 관련
        let font;
        const initialChosungs = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
        let currentPlayerChar;
        const allJungseongs = ['ㅗ', 'ㅜ', 'ㅑ', 'ㅕ', 'ㅏ', 'ㅣ', 'ㅡ', 'ㅔ', 'ㅐ', 'ㅚ', 'ㅟ', 'ㅝ', 'ㅞ', 'ㅢ', 'ㅘ', 'ㅙ']; // 모든 중성
        const allJongseongs = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ']; // 모든 종성 (빈 문자열은 받침 없음)
        const letters = [];
        let letterJustEaten = null; // 이번 충돌에서 먹은 글자를 저장하는 변수
        const collectedLetters = []; // 먹은 글자들을 저장하는 배열
        const minLettersForNext = 6; // 다음 단계로 넘어가기 위한 최소 자모 수
        const initialLetterCount = 50; // 초기 생성할 자모 개수
        // UI 요소
        const startSelection = document.getElementById('start-selection');
        const chosungList = document.getElementById('chosung-list');
        const gameContainer = document.getElementById('threejs-container');
        const startInfo = document.getElementById('start-info');
        const nextButton = document.getElementById('next-button');
        const combinationArea = document.getElementById('combination-area');
        const capturedJamoDiv = document.getElementById('captured-jamo');
        const captureResultButton = document.getElementById('capture-result');
        let draggableJamoElements = [];
        let draggedJamo = null;
        let dragOffsetX, dragOffsetY;

        // 초성 선택 이벤트 리스너
        chosungList.addEventListener('click', (event) => {
            if (event.target.classList.contains('chosung-option')) {
                currentPlayerChar = event.target.dataset.chosung;
                startSelection.classList.add('hidden');
                gameContainer.style.display = 'block';
                init();
                animate();
            }
        });

        // 다음 단계 버튼 클릭 이벤트 리스너
        nextButton.addEventListener('click', () => {
            gameContainer.style.display = 'none';
            combinationArea.style.display = 'flex';
            displayCapturedJamo();
        });

        function init() {
            // 장면 생성
            scene = new THREE.Scene();
            // 카메라 생성 (Orthographic)
            const aspectRatio = window.innerWidth / window.innerHeight;
            const viewSize = 30;
            camera = new THREE.OrthographicCamera(-viewSize * aspectRatio / 2, viewSize * aspectRatio / 2, viewSize / 2, -viewSize / 2, 0.1, 1000);
            camera.position.set(0, 0, 20);
            camera.lookAt(0, 0, 0);
            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0xffffff); // Three.js 배경색을 흰색으로 설정
            gameContainer.appendChild(renderer.domElement);

            // 폰트 로더
            const fontLoader = new FontLoader();
            fontLoader.load(
                'Gothic A1_Bold.json',
                function (loadedFont) {
                    font = loadedFont;
                    createPlayer();
                    createInitialLetters(); // 초기 모든 자모 생성
                    updateNextButtonVisibility();
                    animate();
                },
                undefined,
                function (err) {
                    console.error('폰트 로딩 에러:', err);
                }
            );

            // 키보드 이벤트 리스너
            document.addEventListener('keydown', onKeyDown);

            // 창 크기 변경 리스너
            window.addEventListener('resize', onWindowResize);

            updateNextButtonVisibility(); // 초기 상태에서 버튼 숨김
        }

        function createTextSegment(char, color) {
            const textGeometry = new TextGeometry(char, {
            font: font,
            size: 1,
            height: 0.1,
            curveSegments: 12
            });
            const textMaterial = new THREE.MeshBasicMaterial({ color: color });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textGeometry.computeBoundingBox();
            textMesh.geometry.center();

            return textMesh;
        }

        function createPlayer() {
            if (!font) return;
            const headSegment = createTextSegment(currentPlayerChar, 0xFF0000);

            // 머리 배경 원 생성 및 추가 (항상 보임, 분홍색)
            const circleGeometryHead = new THREE.CircleGeometry(1.4, 32);
            const backgroundColorHead = new THREE.Color(0xff99fa);
            const circleMaterialHead = new THREE.MeshBasicMaterial({ color: backgroundColorHead });
            const backgroundCircleHead = new THREE.Mesh(circleGeometryHead, circleMaterialHead);
            backgroundCircleHead.position.z = -0.1;
            headSegment.add(backgroundCircleHead);

            playerSegments.push(headSegment);
            scene.add(headSegment);
            collectedLetters.push({ value: currentPlayerChar, mesh: headSegment, background: backgroundCircleHead }); // 배경 원 정보 저장
            segmentPositions.push(new THREE.Vector3()); // 초기 위치 저장
        }

        function addSegment(char) {
            if (!font) return;
            const newSegment = createTextSegment(char, 0x7FFF00);

            // 꼬리 배경 원 생성 및 추가 (항상 보임, 분홍색)
            const circleGeometry = new THREE.CircleGeometry(1.4, 32);
            const backgroundColor = new THREE.Color(0xff99fa);
            const circleMaterial = new THREE.MeshBasicMaterial({ color: backgroundColor });
            const backgroundCircle = new THREE.Mesh(circleGeometry, circleMaterial);
            backgroundCircle.position.z = -0.1;
            newSegment.add(backgroundCircle);

            playerSegments.push(newSegment);
            scene.add(newSegment);
            collectedLetters.push({ value: char, mesh: newSegment, background: backgroundCircle }); // 배경 원 정보 저장
            segmentPositions.push(playerSegments[playerSegments.length - 2].position.clone().sub(currentDirection.clone().multiplyScalar(segmentLength)));
            updateNextButtonVisibility();
        }

        function createInitialLetters() {
            if (!font || playerSegments.length === 0) return;

            for (let i = 0; i < initialLetterCount; i++) {
                const type = Math.random() < 0.5 ? 'jungseong' : 'jongseong';
                const value = type === 'jungseong' ? allJungseongs[Math.floor(Math.random() * allJungseongs.length)] : allJongseongs[Math.floor(Math.random() * allJongseongs.length)];
                const textMesh = createTextSegment(value, 0x7FFF00);

                // 배경 원 생성 및 추가 (초기 숨김)
                const circleGeometryLetter = new THREE.CircleGeometry(1.2, 32);
                const backgroundColorLetter = new THREE.Color(0xff99fa);
                const circleMaterialLetter = new THREE.MeshBasicMaterial({ color: backgroundColorLetter });
                const backgroundCircleLetter = new THREE.Mesh(circleGeometryLetter, circleMaterialLetter);
                backgroundCircleLetter.position.z = -0.1;
                backgroundCircleLetter.visible = false; // 초기 숨김
                textMesh.add(backgroundCircleLetter);

                const range = 30;
                const position = new THREE.Vector3((Math.random() - 0.5) * range * 2, (Math.random() - 0.5) * range * 2, 0);
                textMesh.position.copy(position);
                scene.add(textMesh);
                letters.push({ mesh: textMesh, type: type, value: value, eaten: false, background: backgroundCircleLetter }); // 배경 원 정보 저장
            }
        }

        function createLetters() {
            // 더 이상 새로운 자모를 생성하지 않습니다.
        }

        function onKeyDown(event) {
            isMoving = true;
            startInfo.classList.add('hidden');
            switch (event.key) {
                case 'ArrowUp':
                    targetDirection.set(0, 1, 0);
                    break;
                case 'ArrowDown':
                    targetDirection.set(0, -1, 0);
                    break;
                case 'ArrowLeft':
                    targetDirection.set(-1, 0, 0);
                    break;
                case 'ArrowRight':
                    targetDirection.set(1, 0, 0);
                    break;
            }
        }

        function checkCollision() {
            if (playerSegments.length === 0) return;
            const headPos = playerSegments[0].position.clone();
            const viewSize = 30;
            const aspectRatio = window.innerWidth / window.innerHeight;
            const boundaryX = viewSize * aspectRatio / 2 - 1;
            const boundaryY = viewSize / 2 - 1;

            // 화면 경계 충돌 체크
            if (headPos.x > boundaryX) headPos.x = boundaryX;
            if (headPos.x < -boundaryX) headPos.x = -boundaryX;
            if (headPos.y > boundaryY) headPos.y = boundaryY;
            if (headPos.y < -boundaryY) headPos.y = -boundaryY;
            playerSegments[0].position.copy(headPos);

            for (let i = letters.length - 1; i >= 0; i--) {
                const letter = letters[i];
                if (letter.mesh && !letter.eaten) { // 먹히지 않은 자모만 충돌 검사
                    const letterPos = letter.mesh.position.clone();
                    const distance = headPos.distanceTo(letterPos);
                    if (distance < 1) {
                        addSegment(letter.value);
                        scene.remove(letter.mesh);
                        letter.mesh = null; // Three.js 객체 제거
                        letter.eaten = true; // 먹힘 상태로 변경
                        letterJustEaten = letter;
                        if (letter.background) {
                            letter.background.visible = true; // 먹었을 때 배경 원 보이기
                        }
                        break;
                    }
                }
            }
            letterJustEaten = null; // 다음 프레임에서 충돌 감지 가능하도록 초기화
        }

        /*function gameOver() {
            isMoving = false;
            alert('게임 오버!');
            // TODO: 게임 재시작 로직
        }*/

        function move() {
            if (!isMoving || playerSegments.length === 0) return;

            // 부드러운 방향 전환
            currentDirection.lerp(targetDirection.clone().normalize(), rotateSpeed);
            currentDirection.normalize();

            // 머리 이동
            const head = playerSegments[0];
            segmentPositions[0] = head.position.clone();
            head.position.add(currentDirection.clone().multiplyScalar(moveSpeed));

            // 몸통 이동
            for (let i = 1; i < playerSegments.length; i++) {
                const prevPos = segmentPositions[i - 1].clone();
                const currentSegment = playerSegments[i];
                const targetPos = prevPos.sub(currentDirection.clone().multiplyScalar(segmentLength));
                currentSegment.position.lerp(targetPos, 0.8); // alpha 값을 높여 더 빠르게 따라가도록 조정
                segmentPositions[i] = currentSegment.position.clone(); // 위치 업데이트를 lerp 이후로 이동
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            move();
            checkCollision();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const aspectRatio = window.innerWidth / window.innerHeight;
            const viewSize = 30;
            camera.left = -viewSize * aspectRatio / 2;
            camera.right = viewSize * aspectRatio / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateNextButtonVisibility() {
            if (collectedLetters.length >= minLettersForNext) {
                nextButton.classList.remove('hidden');
            } else {
                nextButton.classList.add('hidden');
            }
        }

        function displayCapturedJamo() {
            capturedJamoDiv.innerHTML = '획득한 자모: ';
            draggableJamoElements = [];
            collectedLetters.forEach(item => {
                const jamoSpan = document.createElement('span');
                jamoSpan.textContent = item.value;
                jamoSpan.className = 'draggable-jamo';
                capturedJamoDiv.appendChild(jamoSpan);
                draggableJamoElements.push(jamoSpan);
            });
            setupDragAndDrop();
        }

        function setupDragAndDrop() {
            draggableJamoElements.forEach(jamoElement => {
                jamoElement.addEventListener('mousedown', onDragStart);
            });
        }

        function onDragStart(event) {
            draggedJamo = event.target;
            dragOffsetX = event.clientX - draggedJamo.getBoundingClientRect().left;
            dragOffsetY = event.clientY - draggedJamo.getBoundingClientRect().top;
            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
            draggedJamo.style.position = 'absolute';
            draggedJamo.style.zIndex = 1000;
        }

        function onDragMove(event) {
            if (!draggedJamo) return;
            draggedJamo.style.left = event.clientX - dragOffsetX + 'px';
            draggedJamo.style.top = event.clientY - dragOffsetY + 'px';
        }

        function onDragEnd() {
            if (!draggedJamo) return;
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
            draggedJamo = null;
        }
    </script>
</body>
</html>
